#include "main.h"
#include <string.h>

// Peripheral handles as generated by Cube
I2C_HandleTypeDef hi2c1;
UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;

// Functions generated by Cube
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_TIM3_Init(void);

// Various user functions
void TIM3_Init();							// Timer 3 setup
void USART1_IRQHandler(void);				// USART1 global interrupt hanlder
void TIM3_IRQHandler(void);					// TIM3 interrupt handler

// Sensiron SFM4100 address is actually 0x01 shifted to the left by 1 bit
// The datasheet wrongly shows bit 7 of the address field set
#define SENSOR_ADDR		(uint16_t)(0x01 << 1)
#define POLYNOMIAL 0x131 //P(x)=x^8+x^5+x^4+1 = 100110001

/**
 * SFM4100 user commands list
 * Each SFM4100 command returns or expects 2 bytes with the exception of the last 3
 */
uint8_t user_reg_w = 0xe2;	// 16 bits
uint8_t user_reg_r = 0xe3; // 16 bits
uint8_t adv_user_reg_w = 0xe4; // 16 bits
uint8_t adv_user_reg_r = 0xe5; // 16 bits
uint8_t read_only_reg1_r = 0xe7;
uint8_t read_only_reg2_r = 0xe9;
uint8_t trigger_flow_measurement = 0xf1;
uint8_t trigger_temp_measurement = 0xf3;
uint8_t trigger_vdd_measurement = 0xf5; // Not implemented on SFM4100
uint8_t eeprom_w = 0xfa;
uint8_t eeprom_r = 0xfa;
uint8_t soft_reset = 0xfe;

// Measurement types
typedef enum {
	FLOW					= 0xf1,
	TEMP 					= 0xf3,
	VDD						= 0xf5,
}SFM4100_Measurement_Type;

// SF04 eeprom map
#define EE_ADR_SN_CHIP 0x02E8		// 10-byte array
#define EE_ADR_SN_PRODUCT 0x02F8	// 32-bit uint
#define EE_ADR_SCALE_FACTOR 0x02B6
#define EE_ADR_FLOW_UNIT 0x02B7

// SFM4100 API
uint8_t sfm4100_get_eeprom_base_address(uint16_t *p_address);
uint8_t sfm4100_read_register(uint8_t reg, uint16_t *p_register_value);
uint8_t sfm4100_write_register(uint8_t reg, uint16_t *p_register_value);
uint8_t sfm4100_read_serial_number(uint32_t *p_serial_number);
uint8_t sfm4100_read_scale_factor(uint16_t *p_scale_factor);
uint8_t sfm4100_read_flow_unit(char *flow_unit); // may be 11 bytes
uint8_t sfm4100_soft_reset();
uint8_t sfm4100_read_eeprom(uint16_t eeprom_start_address, uint8_t size, uint8_t eeprom_data[]);
uint8_t sfm4100_check_crc(uint8_t data[], uint8_t nbrOfBytes, uint8_t checksum);
uint8_t sfm4100_measure(SFM4100_Measurement_Type measurement_type, uint16_t *p_address);

// SFM4100 variables
uint8_t sfm4100_data_buffer[32] = { 0 };		// Receive buffer for SFM4100 functions
uint8_t sfm4100_error = 0;
uint16_t sfm4100_register_value = 0;
uint32_t sfm4100_serial_number = 0;

// Timer 3 Macros
// @TODO: Test if macros are working
#define TIMER3_START()				(TIM3->CR1 |= TIM_CR1_CEN)
#define TIMER3_INTERRUPT_FLAG()		(TIM3->SR & TIM_SR_UIF)
#define TIMER3_RESTART()				(TIM3->CNT = 0)

// Modbus variables
char modbus_buffer[8] = {0};			// Modbus data buffer. Commands will be no more than 8 bytes long
volatile uint16_t m_buffer_index = 0;	// Index of modbus buffer

// Message
char *msg = "Hello World!\n\r";
uint8_t hs = 0;
char uart_buffer[64] = {0};

int main(void) {

	// Initialize peripherals
	HAL_Init();
	SystemClock_Config();
	MX_GPIO_Init();
	MX_I2C1_Init();
	TIM3_Init();
	MX_USART2_UART_Init();
	MX_USART1_UART_Init();

	// Get chip serial number
	// Get product serial number
	// Get scale factor
	// Get flow unit


	sfm4100_soft_reset();														// Issue soft reset
	HAL_Delay(500);																// Start-up delay
	sfm4100_read_register(adv_user_reg_r, &sfm4100_register_value); 			// Get Adv User Register
	sfm4100_register_value |= 0xe00;											// Change flow resolution to 16 bits
	sfm4100_write_register(adv_user_reg_w, &sfm4100_register_value);			// Write new value to Adv User Register
	uint8_t err = sfm4100_read_serial_number(&sfm4100_serial_number);			// Get device serial number

	while (1) {
		sfm4100_error = 0;														// Clear error
		sfm4100_register_value = 0;												// Clear temporary register value
		HAL_Delay(250);
		HAL_GPIO_TogglePin(LD3_GPIO_Port, LD3_Pin);

		sfm4100_error = sfm4100_measure(FLOW, &sfm4100_register_value);			// Trigger flow measurement
		if (sfm4100_error == 0) {
			sprintf(uart_buffer, "Flow: %d sccm\n\r", sfm4100_register_value);
			HAL_UART_Transmit(&huart2, uart_buffer, strlen(uart_buffer), 1000);
		}

		// @TODO USART1 IRQ routine - need interrupt on receive
		/* Put every received char in a buffer and start the timer.
		 * If the timer expires, a frame is received. Raise a flag to be polled in main */
		// hs = HAL_UART_Transmit(&huart1, msg, 14, 1000);
	}

}
/****************************************************************************************************************/
/**
 * @brief System Clock Configuration
 * @retval None
 */
/****************************************************************************************************************/
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
	RCC_PeriphCLKInitTypeDef PeriphClkInit = { 0 };

	/** Initializes the CPU, AHB and APB busses clocks
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI
			| RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
	RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}
	/** Initializes the CPU, AHB and APB busses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {
		Error_Handler();
	}
	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1
			| RCC_PERIPHCLK_I2C1;
	PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
	PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) {
		Error_Handler();
	}
}

/****************************************************************************************************************/
/**
 * @brief I2C1 Initialization Function
 * @param None
 * @retval None
 */
/****************************************************************************************************************/
static void MX_I2C1_Init(void) {
	hi2c1.Instance = I2C1;
	hi2c1.Init.Timing = 0x00201D2B;
	hi2c1.Init.OwnAddress1 = 0;
	hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c1.Init.OwnAddress2 = 0;
	hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c1) != HAL_OK) {
		Error_Handler();
	}
	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE)
			!= HAL_OK) {
		Error_Handler();
	}
	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK) {
		Error_Handler();
	}
}

/****************************************************************************************************************/
/**
 * @brief USART2 Initialization Function
 * @param None
 * @retval None
 */
/****************************************************************************************************************/
static void MX_USART2_UART_Init(void) {

	huart2.Instance = USART2;
	huart2.Init.BaudRate = 9600;
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_NONE;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	if (HAL_UART_Init(&huart2) != HAL_OK) {
		Error_Handler();
	}

}

/****************************************************************************************************************/
/**
 * @brief USART1 Initialization Function
 * @param None
 * @retval None
 */
/****************************************************************************************************************/
static void MX_USART1_UART_Init(void) {
	huart1.Instance = USART1;
	huart1.Init.BaudRate = 9600;
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
	huart1.Init.StopBits = UART_STOPBITS_2;
	huart1.Init.Parity = UART_PARITY_NONE;
	huart1.Init.Mode = UART_MODE_TX_RX;
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
	huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;

	if (HAL_RS485Ex_Init(&huart1, UART_DE_POLARITY_HIGH, 16, 16) != HAL_OK) {
		Error_Handler();
	}

	// Set interrupt priority & enable interrupts
	HAL_NVIC_SetPriority(USART1_IRQn, 5, 5);
	__HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
	//__HAL_UART_ENABLE_IT(&huart1, UART_IT_TXE);
	HAL_NVIC_EnableIRQ(USART1_IRQn);
}

/****************************************************************************************************************/
/**
 * @brief GPIO Initialization Function. LD3 is on-board LED; Debug_Pin is PB4 and is used for various debug
 * purposes
 * @param None
 * @retval None
 */
/****************************************************************************************************************/
static void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOF_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(LD3_GPIO_Port, LD3_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(Debug_Pin_Port, Debug_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin : LD3_Pin and Debug_Pin*/
	GPIO_InitStruct.Pin = LD3_Pin | Debug_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(LD3_GPIO_Port, &GPIO_InitStruct);

}

/**
 * Initialize Timer 3 for generating an interrupt every 4.096ms
 */
void TIM3_Init() {
	// Timer 3 is used as an upcounter. Clock frequency: 72MHz. Note that the function does NOT start the timer
	// Calculating the 3.5 characters time for detecting Modbus end of frame
	// Assuming 9600, 8, 2, N
	// Character time = 11 * (1/9600) = 1.146ms
	// 3.5 * character time = 4.011ms
	// Let timer prescaler = 9 and auto-reload register = 32768
	// Therefore timer period = (Prescaler*Auto-reload)/72MHz = 4.096ms
	// Interrupt enabled. Need to clear interrupt bit in TIM3->SR, UIF
	__HAL_RCC_TIM3_CLK_ENABLE();			// Enable Timer 3 clock
	TIM3->ARR = 32768;						// Auto-reload register
	TIM3->PSC = 0x09;						// Prescaler
	TIM3->DMAR = 0;							// It's not 0x00 at start for some reason
	DBGMCU->APB1FZ |= DBGMCU_APB1_FZ_DBG_TIM3_STOP;		// Timer 3 clock stops in Debug mode

	HAL_NVIC_SetPriority(TIM3_IRQn, 5, 5);	// Set interrupt priority
	TIM3->DIER |= TIM_DIER_UIE;				// Update interrupt enabled
	HAL_NVIC_EnableIRQ(TIM3_IRQn);

	TIM3->SR = 0;							// Clear status register
}

/****************************************************************************************************************/
/**
 * USART1 interrupt service routine
 */
/****************************************************************************************************************/
void USART1_IRQHandler(void) {
//	if (__HAL_UART_GET_FLAG(&huart1, USART_ISR_TXE)) {
//		// Hanlde transmit interrupt
//	} else if (__HAL_UART_GET_FLAG(&huart1, USART_ISR_RXNE)) {
//		// Handle receive interrupt
//		// Clear flag
//		// char ch = USART1->RDR;
//		// @TODO
//		// Check if timer 3 has expired
//		// If true, check if buffer is not empty
//		// If there's something in the buffer, put it in a queue to be consumed in main loop
//		// If timer has not expired, put received char in buffer and restart timer
//
//		if (TIMER3_INTERRUPT_FLAG() == 0) {				// Check if timer has not expired, which means we are still in reception phase
//			TIMER3_RESTART();							// Restart the timer
//			modbus_buffer[m_buffer_index++] = USART1->RDR;
//
//			if (m_buffer_index == 8) {					// If 8 bytes already received, alert main and stop timer
//
//			}
//		} else {
//			// Inform main about a complete new message being received
//			// Start the timer again; it's been disabled int TIM3 ISR
//			TIMER3_START();
//			m_buffer_index = 0;							// Put first character of the message in pos. 0
//			modbus_buffer[m_buffer_index++] = USART1->RDR;
//		}
//	}
	// Clear receive interrupt flag
	char ch = USART1->RDR;
}

/****************************************************************************************************************/
/**
 * Timer 3 interrupt service routine. Triggered every 4.096ms
 */
/****************************************************************************************************************/
void TIM3_IRQHandler(void) {
	TIM3->SR &= ~(TIM_SR_UIF);		// Clear inerrupt flag
	TIM3->SR = TIM3->SR;			// Sometimes interrupts can be triggered twice. See http://www.keil.com/support/docs/3928.htm
	TIM3->CR1 &= ~(TIM_CR1_CEN);	// Disable timer
}

/****************************************************************************************************************/
/**
 * SFM4100 function for calculating EEPROM base address
 * @param p_address A pointer which will be set to the EEPROM base address
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_get_eeprom_base_address(uint16_t *p_address) {
	uint8_t error = 0;
	error |= sfm4100_read_register(read_only_reg2_r, p_address);

	*p_address &= 0x07;
	*p_address *= 0x300;

	return error;
	/**
	 * The EEPROM address is composed of an EEPROM base address and an address offset.
	 * To determine the base EEPROM address for general sensor information,
	 * bit <2:0> of Read-Only Register 2 (called active configuration field at boot time)
	 * must be multiplied by h300.
	 * Then the Wordadr Offset of following table must be added to that address.
	 * See Application Note for I2C Flow and Differential Pressure Sensors
	 */
}

/****************************************************************************************************************/
/**
 * SFM4100 read register function
 * @param reg The address of the register as defined in this file
 * @param p_register_value The contents of the register will be copied in this pointer
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_read_register(uint8_t reg, uint16_t *p_register_value) {
	uint8_t error = 0;

	error |= HAL_I2C_Master_Transmit(&hi2c1, SENSOR_ADDR, &reg, 0x01, 1000);				// Issue write command
	error |= HAL_I2C_Master_Receive(&hi2c1, SENSOR_ADDR, sfm4100_data_buffer, 0x03, 1000);	// Read contents of register
	error |= sfm4100_check_crc(sfm4100_data_buffer, 2, sfm4100_data_buffer[2]); 					// Check CRC

	uint16_t reg_contents = 0;
	reg_contents |= (uint16_t) (sfm4100_data_buffer[0] << 8);
	reg_contents |= (uint16_t) (sfm4100_data_buffer[1]);
	*p_register_value = reg_contents;

	return error;
}

/****************************************************************************************************************/
/**
 * SFM4100 write register function
 * @param reg The address of the register as defined in this file
 * @param p_register_value The value to be written in the register
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_write_register(uint8_t reg, uint16_t *p_register_value) {
	// A write to a register will be 2 bytes only. Need to concatenate address and reg value
	// Total transfer length: 3 bytes
	uint8_t error = 0;
	uint16_t register_value = *p_register_value;
	uint8_t data[3] = { 0 };
	data[0] = reg;
	data[1] = (uint8_t) (register_value >> 8);
	data[2] = (uint8_t) (register_value & 0xff);

	error |= HAL_I2C_Master_Transmit(&hi2c1, SENSOR_ADDR, data, 0x03, 1000);
	return error;
}

/****************************************************************************************************************/
/**
 * SFM4100 Read serial number of the device
 * @param p_serial_number The serial number will be written into this pointer
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_read_serial_number(uint32_t *p_serial_number) {
	uint8_t error = 0;
	uint16_t eeprom_base_address = 0;
	uint16_t eeprom_address = 0;
	uint32_t serial_number = 0;

	error = sfm4100_get_eeprom_base_address(&eeprom_base_address);					// Get eeprom base address
	eeprom_address = eeprom_base_address + EE_ADR_SN_PRODUCT;						// Get serial number field address in eeprom
	error |= sfm4100_read_eeprom(eeprom_address, 6, sfm4100_data_buffer);			// Read serial number: 2 bytes - CRC - 2 bytes - CRC, total of 6 bytes
	error |= sfm4100_check_crc(sfm4100_data_buffer, 2, sfm4100_data_buffer[2]);		// Check first CRC
	uint8_t *p = &sfm4100_data_buffer[3];											// The second 16-bit register starts at sfm4100_data_buffer[3]
	error |= sfm4100_check_crc(p, 2, p[2]);											// Check second CRC

	serial_number |= (sfm4100_data_buffer[0] << 24);								// Copy the 4 received bytes into the function argument
	serial_number |= (sfm4100_data_buffer[1] << 16);
	serial_number |= (sfm4100_data_buffer[3] << 8);
	serial_number |= (sfm4100_data_buffer[4] << 0);
	*p_serial_number = serial_number;

	return error;
}

/****************************************************************************************************************/
/**
 * SFM4100 Read scale factor
 * @param p_scale_factor The scale factor will be written into this pointer
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_read_scale_factor(uint16_t *p_scale_factor) {
	// @TODO Implement - need EEPROM map
}

/****************************************************************************************************************/
/**
 * SFM4100 Read flow unit
 * @param flow_unit The flow unit will be written into this pointer (20 bytes)
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_read_flow_unit(char *flow_unit) {
	// @TODO Implement - need EEPROM map
}

/****************************************************************************************************************/
/**
 * SFM4100 Soft reset
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_soft_reset() {
	// Issue write command
	// @TODO - check if it's working
	uint8_t error = 0;
	error |= HAL_I2C_Master_Transmit(&hi2c1, SENSOR_ADDR, &soft_reset, 0x01, 1000);
	return error;
}

/****************************************************************************************************************/
/**
 * SFM4100 read EEPROM data
 * @param eeprom_start_address
 * @param size - the number of bytes to read
 * @param eeprom_data - pointer to an array of bytes into which the EEPROM data will be copied
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_read_eeprom(uint16_t eeprom_start_address, uint8_t size, uint8_t eeprom_data[]) {
	uint8_t error = 0;
	uint8_t eeprom_address[3] = {0};														// Create array from read eerpom command and the eeprom address
	eeprom_start_address = ((eeprom_start_address << 4) & 0xfff0);							// Left-shift the eeprom address by 4 bits
	eeprom_address[0] = eeprom_r;															// Command 0xFA
	eeprom_address[1] = (uint8_t) (eeprom_start_address >> 8) & 0xff;						// MSB of the eeprom address
	eeprom_address[2] = (uint8_t) (eeprom_start_address & 0xff);							// LSB of the eeprom address

	error |= HAL_I2C_Master_Transmit(&hi2c1, SENSOR_ADDR, eeprom_address, 0x03, 1000);		// Send command
	error |= HAL_I2C_Master_Receive(&hi2c1, SENSOR_ADDR, eeprom_data, size, 1000);			// Get eeprom data and copy it into the user-supplied array

	return error;
}

/****************************************************************************************************************/
/**
 * Calculate CRC of received data. Function adapred from Sensirion Mass Fwol Meters CRC Calculation application note
 * @param data - checksum is built based on this data
 * @param nbrOfBytes = checksum is built for n bytes of data
 * @param checksum - expected checksum
 * @return 0 on success
 */
/****************************************************************************************************************/
uint8_t sfm4100_check_crc(uint8_t data[], uint8_t nbrOfBytes, uint8_t checksum) {
	uint8_t crc = 0;
	uint8_t byteCtr;
	//calculates 8-Bit checksum with given polynomial
	for (byteCtr = 0; byteCtr < nbrOfBytes; ++byteCtr) {
		crc ^= (data[byteCtr]);
		for (uint8_t bit = 8; bit > 0; --bit) {
			if (crc & 0x80) crc = (crc << 1) ^ POLYNOMIAL;
			else crc = (crc << 1);
		}
	}
	if (crc != checksum) return 1;
	else return 0;
}

/****************************************************************************************************************/
/**
 * Measure flow, temperature or voltage (voltage measurement is not implemented on SFM4100)
 * @param measurement_type FLOW, TEMP or VDD
 * @param p_address Pointer to the 16-bit variable to which the data will be written
 * @return
 */
/****************************************************************************************************************/
uint8_t sfm4100_measure(SFM4100_Measurement_Type measurement_type,
		uint16_t *p_address) {
	uint8_t error = 0;
	uint16_t data = 0;

	switch (measurement_type) {
	case FLOW:
		error |= sfm4100_read_register(trigger_flow_measurement, &data);
		break;
	case TEMP:
		error |= sfm4100_read_register(trigger_temp_measurement, &data);
		break;
	case VDD:
		error |= sfm4100_read_register(trigger_temp_measurement, &data);
		break;
	default:
		break;
	}

	*p_address = data;
	return error;
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM2 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
	/* USER CODE BEGIN Callback 0 */

	/* USER CODE END Callback 0 */
	if (htim->Instance == TIM2) {
		HAL_IncTick();
	}
	/* USER CODE BEGIN Callback 1 */

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */

	/* USER CODE END Error_Handler_Debug */
}

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
